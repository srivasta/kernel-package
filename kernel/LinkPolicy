
   $Id: LinkPolicy,v 1.3 1997/06/25 07:33:27 srivasta Exp $

This is an proposal for packages providing kernel sources, headers,
and image, which attempts to make it possible to have multiple
versions of the kernel headers/source/image on the system
concurrently.

It would be nice if removing a current source/header could roll back
to any older versions still on the system, but that seems hard, though
I think I see a way to do this. (Read on for details).

The source unpack into /usr/src/linux-X.X.XX, and kernel headers only
package unpacks into /usr/src/headers-X.X.XX (so that the
kernel-source and kernel-header package do not need to conflict at
all). /usr/src/linux is a symlink that is maintained current by the
Debian package scripts, pointing to the most recently installed source
or header. We try to ensure that it will always point somewhere sane.

We accommodate multiple versions by having each package include the
kernel version in the name, and provide a corresponding virtual
package.  For example, assuming that a user has kernel versions 1.3.64
and 1.3.95 on her system, we get:

Package Name           Package version         provides
======================================================================
kernel-source-1.3.95    1.3.95-1          kernel-headers, kernel-source
kernel-headers-1.3.95   1.3.95-1          kernel-headers
kernel-image-1.3.95     1.3.95-1          kernel-image
			
kernel-source-1.3.64    1.3.64-3          kernel-headers, kernel-source
kernel-headers-1.3.64   1.3.64-3          kernel-headers
kernel-image-1.3.64     1.3.64-3          kernel-image
======================================================================

The following analysis shows we should have a postinst and postrm for
both headers and source. The image has a postinst, to ask if the user
wants to run LILO. 

======================================================================
Case A:
  upgrade source/header X to source/header Y
  script            action      version on disk
  X prerm                           X
  Y preinst                         X
	             unpack         X
  X postrm upgrade                  X           no change
                     remove         X
  Y postinst                        X           (no harm, if re-links) (a)
----------------------------------------------------------------------
Case B:
  Install source/header Y along with  header/source X
  Y preinst                         X
             unpack                 X,Y
  Y postinst                        X,Y          <---- change link      (b) 
----------------------------------------------------------------------  
Case C:
    remove current source/header X no other source/header exists
  X prerm                           X
                     remove         X'
  X postrm   remove                 X'            <---- remove link        (c)
  X postrm   purge                  X'            no harm in removing link (d)
----------------------------------------------------------------------
Case D:
    remove current source/header X (some version exists)
  X prerm                           X,Y
                     remove        X',Y
  X postrm   remove                X',Y           <---- relink to Y        (f)
  X postrm   purge                 X',Y           <- ignore, or relink to Y(g)
----------------------------------------------------------------------
Case E:
    remove non-current source/header X 
  X prerm                           X,Y
                     remove        X',Y
  X postrm   remove                X',Y           ignore link != X         (h)
  X postrm   purge                 X',Y           <- ignore                (i)
======================================================================

X' is the case when X should be gone, but isn't really since directory
isn't empty (compiling kernels leaves .depends and other files all
over the place, so the directory isn't empty when dpkg removes all the
files listed for that directory).

The problem in handling cases c/d and e/f is that if no other source
or header packages are available, then /usr/src/linux should be
removed, or else it should be rolled back to a previously installed
version.  The hard part is to distinguish between the two cases, and
to discover which is a valid directory to link to. Just searching in
/usr/src is not good enough, because of the possible dreck left by
unclean source directories.

Maybe I should maintain a list of current valid directory names,
updated by postinst like so:
  (echo headers-X.X.XX >> .versionlist)
and removed in postrm like so:
  (cp .versionlist .save$$; grep -v headers-X.X.XX .save$$ > .versionlist)
where .version list is a conffile. last -1 .versionlist will give the
next candidate.


======================================================================
postrm called with argument:
abort-upgrade               -- ignore, no preinst to unwind from
abort-install               -- ignore, no preinst to unwind from   
abort-install               -- ignore, no preinst to unwind from
upgrade <newversion>        -- ignore, same directory
failed-upgrade <oldversion> -- ignore, we didn't change anything in upgrade
disappear                   -- ignore, we are safe, no conflict
remove                      -- ignore unless builtin version is the same as
                               link target, or do last .versionlist; relink
                               to version found or remove link if none
purge                       -- ignore, proper action taken in remove

postinst called with argument:
abort-upgrade     	     -- ignore, no prerm to unwind from
failed-upgrade    	     -- ignore, since we ignore abort-upgrade
abort-deconfigure 	     -- ignore, no prerm to unwind from
abort-remove      	     -- ignore, no prerm to unwind from
abort-upgrade new-version    -- ignore, we didn't change anything in upgrade
configure                    -- link to builtin version
======================================================================






